// Copyright 2021 Upbound Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package natsproxy

import (
	"fmt"
	"math/rand"
	"net/http"
	"sync"
	"time"

	"github.com/nats-io/nats.go"
	"github.com/sirupsen/logrus"
	"google.golang.org/protobuf/proto"
)

func init() {
	rand.Seed(time.Now().UnixNano())
}

// RandomSuffixGetter defines interface get a random suffix for a nats message.
type RandomSuffixGetter interface {
	Get() string
}

// RandomSuffix will generate a random suffix for use in Nats Msg.reply field.
type RandomSuffix struct {
	randomGenerator *rand.Rand // Used for generating suffix
}

// Get a random suffix from generator
func (r *RandomSuffix) Get() string {
	rn := r.randomGenerator.Int63()
	suffix := make([]byte, replySuffixLen)
	for i, l := 0, rn; i < replySuffixLen; i++ {
		suffix[i] = rdigits[l%base]
		l /= base
	}
	return string(suffix)
}

// HTTPProxy proxies http requests through nats to a remote agent
type HTTPProxy struct {
	nc          *nats.Conn
	readTimeout time.Duration
}

// NewHTTPProxy returns an instance that proxies http requests through nats to a remote agent
func NewHTTPProxy(nc *nats.Conn, readTimeout time.Duration) *HTTPProxy {
	return &HTTPProxy{
		nc:          nc,
		readTimeout: readTimeout,
	}
}

// ServeHTTP Serve HTTP request over nats
func (p *HTTPProxy) ServeHTTP(w http.ResponseWriter, req *http.Request, subject string) {
	logrus.Debug("HTTPProxy.ServeHTTP()")
	done := make(chan bool)
	resBroker := NewAgentResponseBroker(w)
	tunnel := newTunnel(p.nc, subject, p.readTimeout, resBroker.handleResponse)
	err := tunnel.open()
	if err != nil {
		logrus.WithError(err).Info("HTTPProxy.ServeHTTP() - failed to send request")
		http.Error(w, "failed to tunnel", http.StatusInternalServerError)
		done <- true
	}
	defer tunnel.close()

	err = tunnel.send(req)
	if err != nil {
		http.Error(w, "failed to send request", http.StatusInternalServerError)
		logrus.WithError(err).Debugf("HTTPProxy.tunnel.send err - %s", err)
		done <- true
	}

	// Wait for done or timeout.
	select {
	case <-tunnel.done:
		logrus.Debug("HTTPProxy.ServeHTTP - tunnel done")
	case <-tunnel.mon.TimedOut():
		logrus.Debug("HTTPProxy.ServeHTTP - connection timeout")
	case <-resBroker.done:
		tunnel.notifyClosingToAgent()
		logrus.Debug("HTTPProxy.ServeHTTP - resBroker done")
	case <-req.Context().Done():
		tunnel.notifyClosingToAgent()
		logrus.Debug("HTTPProxy.ServeHTTP - request context done")
	case <-done:
		logrus.Debug("HTTPProxy.ServeHTTP - done")
	}
}

// NewAgentResponseBroker returns an initialized AgentResponseBroker that
// brokers the nats messages stream generated by AgentResponseWriter
// back into an http response.
func NewAgentResponseBroker(w http.ResponseWriter) *AgentResponseBroker {
	return &AgentResponseBroker{
		w:             w,
		done:          make(chan bool),
		written:       0,
		contentLength: 0,
		mux:           sync.Mutex{},
		seq:           0,
	}
}

// AgentResponseBroker that brokers the nats messages stream generated by AgentResponseWriter
// back into an http response, use NewAgentResponseBroker to initialize.
type AgentResponseBroker struct {
	w             http.ResponseWriter
	done          chan bool
	written       int
	contentLength int
	mux           sync.Mutex
	seq           int32
}

// BindNats brokers data received in a nats message to an http.ResponseWriter
// messages must be an in-order sequence of Responses(protobuf).
// The companion code that generates this stream correctly is AgentResponseWriter.
func (rc *AgentResponseBroker) handleResponse(response *Response) { // nolint: gocyclo
	logrus.Debugf("ARB.BindNats - Received response:\n=========\n%+v\n=======", response)
	if response.TransportInfo.Sequence == 0 { // Expect headers in first payload.
		for k, arr := range response.Header {
			for _, v := range arr.Arr {
				rc.w.Header().Set(k, v)
			}
		}
		logrus.Debugf("ARB.BindNats - headers received - content-length: %d", rc.contentLength)
		rc.w.WriteHeader(int(response.StatusCode))
	}
	if response.Body != nil {
		l, err := rc.w.Write(response.Body)
		if err != nil {
			logrus.Errorf("ARB.BindNats signaling done -> write err %s", err)
			rc.done <- true
		}
		rc.written += l
	}

	// TODO: We can do a max interval flusher here.
	// or pass in when we detect the watch case
	// Good example of possible options.
	// https://github.com/golang/go/blob/4b068cafb5a5e094dd0b7ed37ff73e08309a39e7/src/net/http/httputil/reverseproxy.go#L398-L423
	if f, ok := rc.w.(http.Flusher); ok {
		logrus.Debug("ARB.BindNats - flush")
		f.Flush()
	}
}

type tunnelMon struct {
	timer       *time.Timer
	readTimeout time.Duration
}

func (t *tunnelMon) isKeepAlive(response *Response) bool {
	logrus.Debugf("TunnelMon.IsKeepAlive: %t", response.TransportInfo.KeepAlive)
	if !t.timer.Stop() {
		select {
		case <-t.timer.C:
		default:
		}
	}
	t.timer.Reset(t.readTimeout)
	return response.TransportInfo.KeepAlive
}

func (t *tunnelMon) TimedOut() <-chan time.Time {
	return t.timer.C
}

// newTunnel get a NatsRequest with random generator correctly initialized.
func newTunnel(nc *nats.Conn, subject string, readTimeout time.Duration, respHandler func(response *Response)) *Tunnel {
	return &Tunnel{
		subject:     subject,
		nc:          nc,
		done:        make(chan bool),
		respHandler: respHandler,
		randSuffix: &RandomSuffix{
			randomGenerator: rand.New(rand.NewSource(time.Now().UnixNano())), //nolint gosec
		},
		mon: tunnelMon{
			readTimeout: readTimeout,
		},
	}
}

// Tunnel creates a request that expects 1..n replies from a remote nats client
type Tunnel struct {
	nc          *nats.Conn
	randSuffix  RandomSuffixGetter
	sub         *nats.Subscription
	inbox       string
	subject     string
	reply       string
	sequence    int32
	respHandler func(r *Response)
	mux         sync.Mutex
	done        chan bool
	mon         tunnelMon
}

// open will create a subscription for a request payload and deliver the response message,
// or an error, including a timeout if no message was received properly.
func (t *Tunnel) open() error {
	if t.nc == nil {
		return nats.ErrInvalidConnection
	}
	t.mon.timer = globalTimerPool.Get(t.mon.readTimeout)
	t.inbox = nats.NewInbox()
	// TODO: we could use this directly below in subscribe instead of wildcard, but will consider later.
	t.reply = fmt.Sprintf("%s.%s", t.inbox, t.randSuffix.Get())
	t.mux = sync.Mutex{}

	sub, err := t.nc.QueueSubscribe(fmt.Sprintf("%s.*", t.inbox), emptyQ, t.recv)
	if err != nil {
		return err
	}

	t.sub = sub
	return nil
}

// recv verifies the transport
// - validates of the sequence of messages
// - filters out any keep alives from the agent
// - signals done when transport is closed remotely
func (t *Tunnel) recv(m *nats.Msg) {
	response := &Response{}
	err := proto.Unmarshal(m.Data, response)
	if err != nil {
		logrus.Errorf("Tunnel.recv unmarshal err %s", err)
		t.done <- true
	}
	t.mux.Lock()
	if response.TransportInfo == nil || response.TransportInfo.Sequence != t.sequence {
		logrus.Errorf("Tunnel.recv unexpected sequence; expect %d, received %d", t.sequence, response.TransportInfo.Sequence)
		t.mux.Unlock()
		t.done <- true
		return
	}

	if response.TransportInfo.Closing {
		logrus.Debug("Tunnel.recv remote closing")
		t.mux.Unlock()
		t.done <- true
		return
	}

	if !t.mon.isKeepAlive(response) {
		t.respHandler(response)
	}

	t.sequence++
	t.mux.Unlock()
}

func (t *Tunnel) send(req *http.Request) error {
	logrus.Debugf("Tunnel.send req to subect %s", t.subject)
	out, err := marshalHTTPRequest(req.URL.String(), req)
	if err != nil {
		logrus.WithError(err).Errorf("Tunnel.send - could not marshall request")
		return err
	}

	m := &nats.Msg{
		Data:    out,
		Subject: t.subject,
		Reply:   t.reply,
	}

	return t.nc.PublishMsg(m)
}

func (t *Tunnel) notifyClosingToAgent() {
	logrus.Debugf("Tunnel.notifyClosingToAgent to subect %s", t.subject)
	req := &Request{TransportInfo: &TransportInfo{Sequence: 1, Closing: true}}
	out, err := proto.Marshal(req)
	if err != nil {
		logrus.WithError(err).Errorf("Tunnel.notifyClosingToAgent - could not marshall request")
	}

	m := &nats.Msg{
		Data:    out,
		Subject: t.subject,
		Reply:   t.reply,
	}

	err = t.nc.PublishMsg(m)
	if err != nil {
		logrus.WithError(err).Errorf("Tunnel.notifyClosing - could not publish closing")
	}
}

func (t *Tunnel) close() {
	logrus.Debugf("Tunnel.close")
	if t.mon.timer != nil {
		globalTimerPool.Put(t.mon.timer)
	}

	if t.sub != nil {
		err := t.sub.Unsubscribe()
		if err != nil {
			logrus.Errorf("Tunnel.close - error closing tunnel %s", err)
		}
	}
}
